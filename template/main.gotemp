//This is an auto-generated file, please do not edit it manually
//这是自动生成的文件,请不要手动编辑

package routers

import (
    "github.com/gin-gonic/gin"
    "github.com/gin-gonic/gin/binding"
    "github.com/go-playground/validator/v10"
    "net/http"
    "reflect"
    "strings"
    "sync"
)

var (
    getGin    func() *gin.Engine
    Validator binding.StructValidator = &defaultValidator{}
    Groups                            = make(map[string]*gin.RouterGroup)
    BindByTag                         = map[string]func(any, *gin.Context) error{
        "query": func(obj any, context *gin.Context) error {
            values := context.Request.URL.Query()
            if err := binding.MapFormWithTag(obj, values, "query"); err != nil {
                return err
            }
            return validateBinding(obj)
        },
        "form": func(obj any, context *gin.Context) error {
            req := context.Request
            if req.Method == "POST" || req.Method == "PUT" {
                if context.ContentType() == binding.MIMEMultipartPOSTForm {
                    return binding.FormMultipart.Bind(req, obj)
                } else {
                    return binding.Form.Bind(req, obj)
                }
            }
            return nil
        },
        "json": func(obj any, context *gin.Context) error {
            if context.Request.Method == "POST" || context.Request.Method == "PUT" {
                return context.BindJSON(obj)
            }
            return nil
        },
        "header": func(obj any, context *gin.Context) error {
            return context.BindHeader(obj)
        },
        "path": func(obj any, context *gin.Context) error {
            params := context.Params
            values := make(map[string][]string, len(params))
            for _, param := range params {
                values[param.Key] = []string{param.Value}
            }
            if err := binding.MapFormWithTag(obj, values, "path"); err != nil {
                return err
            }
            return validateBinding(obj)
        },
    }
    regFns []func()
    lock   sync.Mutex
    allMethods=[]string{
        http.MethodGet, http.MethodPost, http.MethodPut, http.MethodPatch,
        http.MethodHead, http.MethodOptions, http.MethodDelete, http.MethodConnect,
        http.MethodTrace,
    }
)

func RegisterErrorHandle(ginEngine *gin.Engine) {
    ginEngine.Use(func(context *gin.Context) {
        context.Next()
        es := context.Errors
        if len(es) == 0 {
            return
        }
        e := es.Last()
        status := context.Writer.Status()
        if status == 200 {
            status = 500
        }
        context.JSON(status, gin.H{
            "msg":  e.Error(),
            "data": e,
        })
    })
}

func RegisterRouter(ginFn func() *gin.Engine) {
    lock.Lock()
    defer lock.Unlock()
    getGin = ginFn
    Groups = make(map[string]*gin.RouterGroup)
    for _, f := range regFns {
        f()
    }
}

func registerRouter(group string, handler gin.HandlerFunc, relativePath string, methods ...string) {
    g:=GetGroup(group)
    if len(methods)<=0 {
        methods=allMethods
    }
    for _, m := range methods {
        g.Handle(m, relativePath , handler)
    }
}

func GetGroup(group string) *gin.RouterGroup {
    routerGroup := Groups[group]
    if routerGroup == nil {
        Groups[group] = getGin().Group(group)
        routerGroup = Groups[group]
    }
    return routerGroup
}
func toBind(structPointer any, funcName string) gin.HandlerFunc {
    t := reflect.TypeOf(structPointer)
    m, ok := t.MethodByName(funcName)
    if t.Kind() == reflect.Pointer {
        t = t.Elem()
        if !ok {
            m, _ = t.MethodByName(funcName)
        }
    }
    index := m.Index
    waitBindTag := findTags(nil, t)
    return func(context *gin.Context) {
        reflectObj := reflect.New(t)
        obj := reflectObj.Interface()
        bind := false
        for _, s := range waitBindTag {
            f := BindByTag[s]
            if f != nil {
                bind = true
                err := f(obj, context)
                if err != nil {
                    context.Status(400)
                    _ = context.Error(err)
                    return
                }
            }
        }
        if bind {
            err := validate(obj)
            if err != nil {
                context.Status(400)
                _ = context.Error(err)
                return
            }
        }
        reflectObj.Method(index).Call([]reflect.Value{reflect.ValueOf(context)})
    }
}

func findTags(waitBindTag []string, t reflect.Type) []string {
    waitBindTag = appendTagByType(t, waitBindTag)
    numField := t.NumField()
    for i := 0; i < numField; i++ {
        field := t.Field(i)
        t := field.Type
        if t.Kind() == reflect.Pointer {
            t = t.Elem()
        }
        name := t.Name()
        if field.Name == name {
            waitBindTag = findTags(waitBindTag, t)
        }
    }
    return waitBindTag
}
func contains(arr []string, test string) bool {
    for _, s := range arr {
        if s == test {
            return true
        }
    }
    return false
}
func appendTagByType(t reflect.Type, waitBindTag []string) []string {
    for i := 0; i < t.NumField(); i++ {
        tag := t.Field(i).Tag
        if tag == "" {
            continue
        }
        split := strings.Split(string(tag), " ")
        for _, s := range split {
            types := strings.SplitN(s, ":", 2)[0]
            if types != "" && !contains(waitBindTag, types) {
                waitBindTag = append(waitBindTag, types)
            }
        }
    }
    return waitBindTag
}

func validate(obj any) error {
    if Validator == nil {
        return nil
    }
    return Validator.ValidateStruct(obj)
}

func validateBinding(obj any) error {
    if binding.Validator == nil {
        return nil
    }
    return binding.Validator.ValidateStruct(obj)
}

type defaultValidator struct {
    once     sync.Once
    validate *validator.Validate
}

func (v *defaultValidator) ValidateStruct(obj interface{}) error {
    if obj == nil {
        return nil
    }
    v.once.Do(func() {
        v.validate = validator.New()
    })
    value := reflect.ValueOf(obj)
    switch value.Kind() {
    case reflect.Ptr:
        return v.ValidateStruct(value.Elem().Interface())
    case reflect.Struct:
        return v.validate.Struct(obj)
    case reflect.Slice, reflect.Array:
        count := value.Len()
        validateRet := make(binding.SliceValidationError, 0)
        for i := 0; i < count; i++ {
            if err := v.ValidateStruct(value.Index(i).Interface()); err != nil {
                validateRet = append(validateRet, err)
            }
        }
        if len(validateRet) == 0 {
            return nil
        }
        return validateRet
    default:
        return nil
    }
}

func (v *defaultValidator) Engine() interface{} {
    v.lazyinit()
    return v.validate
}

func (v *defaultValidator) lazyinit() {
    v.once.Do(func() {
        v.validate = validator.New()
    })
}
